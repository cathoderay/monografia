Universidade Federal do Rio de Janeiro
Instituto de Matem´tica
a
Departamento de Ciˆncia da Computa¸˜o
e
ca
Rio de Janeiro, RJ - Brasil

Aplica¸˜o do algoritmo Perceptually Important Points em s´ries
ca
e
temporais de datacenters
Ronald Andreu Kaiser
Orientadora:
Adriana Santarosa Vivacqua

Dezembro de 2010

Aplica¸ao do algoritmo Perceptually Important Points em s´ries
c˜
e
temporais de datacenters
Ronald Andreu Kaiser
Projeto Final de Curso submetido ao Departamento de Ciˆncia da Computa¸ao do
e
c˜
Instituto de Matem´tica da Universidade Federal do Rio de Janeiro como parte dos
a
requisitos necess´rios para obten¸˜o do grau de Bacharel em Inform´tica.
a
ca
a

Apresentado por:

Ronald Andreu Kaiser

Aprovado por:

Adriana Santarosa Vivacqua
D.Sc. COPPE/UFRJ

Prof. 1

Prof. 2

RIO DE JANEIRO, RJ - BRASIL
Dezembro de 2010

Agradecimentos
Agrade¸o a todo o Universo, por ter se organizado de tal maneira que fosse poss´ a
c
ıvel
realiza¸˜o desse projeto. Obrigado por sua complexidade, que torna nossas vidas menos
ca
enfadonhas e previs´
ıveis.
Agrade¸o a minha m˜e, Monique E. C. D. Nitsche, por ter me ajudado a experimentar
c
a
a vida e por sua luta em dar o melhor de si para que eu pudesse sobreviver e alcan¸ar
c
meus objetivos.
Agrade¸o a Paloma Bispo dos Santos por ser a mulher fascinante que ´ e ter me
c
e
ajudado consideravelmente quando precisei, apesar de n˜o ter reconhecido seu amor a
a
tempo.
Agrade¸o a minha tia Vera Sarres, por ter aturado minhas excentricidades por esses
c
anos e me dado abrigo e conforto.
Agradecimento especial aos amigos da casa Intelie, Ricardo Clemente, Pedro Teixeira,
Hubert Fonseca e o grande Falc˜o pelo apoio e incentivo que vocˆs me deram durante
a
e
todo o tempo que nos conhecemos. Obrigado pelas grandes li¸˜es de vida e experiˆncias
co
e
que vocˆs me proporcionaram. Obrigado pela oportunidade que foi fundamental para
e
realiza¸˜o deste trabalho e a compreens˜o nos momentos que precisei me ausentar para
ca
a
termin´-lo. Serei eternamente grato a vocˆs.
a
e
Agrade¸o a Anna Cruz pelas conversas e por ter me ajudado a tirar alguns screenshots
c
para a vers˜o ﬁnal e ao Rodolfo Carvalho, pelas coisas que aprendi com ele.
a
Agrade¸o a minha orientadora, Adriana S. Vivacqua, por ter aceitado esse desaﬁo, seu
c
incentivo e indispens´vel ajuda nesse trabalho.
a
Agrade¸o a UFRJ por, apesar de todos os seus defeitos, prezar pelo ensino de qualidade
c
e excelˆncia de computa¸ao.
e
c˜
Agrade¸o ao Tiago S. da Silva, por sua amizade e pelos papos ﬁlos´ﬁcos que tivemos
c
o
durante o curso.
Agrade¸o a Adriana Pinho pelas prazerosas conversas sobre ciˆncia e sociedade, al´m
c
e
e
de conselhos para essa monograﬁa.
Agrade¸o tamb´m a todas as in´meras pessoas e situa¸˜es que me ajudaram direta ou
c
e
u
co
indiretamente a ser uma pessoa melhor.

Resumo
Kaiser, R. A. Aplica¸ao do algoritmo Perceptually Important Points em s´ries temporais
c˜
e
de datacenters.
O prop´sito deste trabalho ´ auxiliar operadores de datacenters na visualiza¸˜o de gr´o
e
ca
a
ﬁcos de s´ries temporais, que representam a evolu¸ao do comportamento de seus equipae
c˜
mentos e servi¸os. Para tanto, foi buscada inspira¸ao em um algoritmo utilizado para
c
c˜
o reconhecimento de padr˜es em s´ries temporais do mercado ﬁnanceiro. O algoritmo
o
e
Perceptually Important Points ao mesmo tempo que contribui para a redu¸˜o de dimenca
sionalidade, fornece um mecanismo automatizado de elei¸ao dos pontos mais importantes
c˜
de uma s´rie temporal para um observador humano, favorecendo, deste modo, sua visue
aliza¸˜o e tr´fego pela rede. A implementa¸˜o do algoritmo e sua implanta¸˜o em um
ca
a
ca
ca
sistema de monitora¸ao de datacenters j´ existente, hoje utilizado por grandes datacenters
c˜
a
do Brasil, constituem o cerne deste trabalho.
Palavras-Chave: S´ries Temporais, Redu¸˜o de dimensionalidade, Perceptually Ime
ca
portant Points, Datacenters, Clojure.

Abstract
Kaiser, R. A. Aplica¸ao do algoritmo Perceptually Important Points em s´ries temporais
c˜
e
de datacenters.
The main purpose of this work is helping operators of datacenters in the task of visualizing the behaviour of their devices and services through time, represented by large
time series. In order to accomplish that, a technique used in pattern recognition from the
ﬁnancial market context was choosed. The “Perceptually Important Points” algorithm
gives a method for dimensionality reduction and a mechanism to automatically extract
the most important points from a human observer perspective, favouring compression and
a good visualization of time series with high dimensionality. The implementation of the
algorithm and its integration in an existing monitoring system was explored and encompasses the content of this work.
Keywords: Time series, Dimensionality Reduction, Perceptually Important Points,
Datacenters, Clojure.

Lista de Figuras
2.1
2.2
2.3
2.4
2.5
2.6

Pre¸o de fechamento de a¸oes da IBM - 2010. . . . . . . .
c
c˜
Padr˜es de tendˆncia e sazonalidade em s´ries temporais .
o
e
e
Piecewise Linear Approximation . . . . . . . . . . . . . . .
Compara¸˜o entre algoritmos de representa¸ao. . . . . . .
ca
c˜
Fam´ de Wavelets. . . . . . . . . . . . . . . . . . . . . .
ılia
Gr´ﬁcos t´
a
ıpicos no dia a dia de opera¸˜o de um datacenter
ca

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

10
11
12
13
14
16

3.1
3.2
3.3

Evolu¸˜o do algoritmo PIP . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
ca
Distˆncia vertical. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
a
Variˆncia inﬂuencia n´mero de PIPs . . . . . . . . . . . . . . . . . . . . . 22
a
u

4.1

Comparativo entre as 3 vers˜es implementadas . . . . . . . . . . . . . . . . 27
o

5.1
5.2
5.3

Arquitetura do sistema HOLMES . . . . . . . . . . . . . . . . . . . . . . . 29
Gr´ﬁcos gerados a partir do algoritmo PIP no sistema HOLMES . . . . . . 31
a
Gr´ﬁcos gerados a partir do algoritmo PIP no sistema HOLMES . . . . . . 32
a

D.1 S´rie original com 8582 pontos reduzida com PIP para 300 pontos . . . . . 46
e

1

Lista de Tabelas
4.1
4.2

Tempos de execu¸˜o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
ca
Tempos de execu¸˜o para as duas melhores vers˜es . . . . . . . . . . . . . 27
ca
o

2

Lista de pseudo-algoritmos
1
2
3

Pseudo-algoritmo Perceptually Important Points . . . . . . . . . . . . . . . 20
Pseudo-algoritmo Perceptually Important Points 2 . . . . . . . . . . . . . . 21
Pseudo-algoritmo Perceptually Important Points 3 . . . . . . . . . . . . . . 22

3

Sum´rio
a
1 Introdu¸˜o
ca
1.1 Motiva¸ao .
c˜
1.2 Objetivos .
1.3 Metodologia
1.4 Organiza¸ao
c˜

. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
da Monograﬁa

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

6
7
7
8
8

2 S´ries temporais
e
2.1 Caracter´
ısticas . . . . . . . . . . . . . . . . .
2.1.1 Dependˆncia de observa¸˜es . . . . . .
e
co
2.1.2 Alta dimensionalidade . . . . . . . . .
2.1.3 Sazonalidade . . . . . . . . . . . . . .
2.1.4 Tendˆncia . . . . . . . . . . . . . . . .
e
2.2 Representa¸˜o e redu¸ao de dimensionalidade
ca
c˜
2.2.1 Algoritmos utilizados . . . . . . . . . .
2.3 S´ries temporais de datacenters . . . . . . . .
e

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

9
10
10
10
11
11
12
12
15

3 Perceptually Important Points
3.1 Ideia do algoritmo . . . . . . .
3.2 C´lculo de distˆncias . . . . . .
a
a
3.3 Pseudo-algoritmo . . . . . . . .
3.3.1 An´lise de Complexidade
a
3.4 C´lculo de erro . . . . . . . . .
a
3.5 Limita¸oes do algoritmo . . . .
c˜

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

17
17
19
20
20
21
22

4 Implementa¸˜o do algoritmo
ca
4.1 Clojure . . . . . . . . . . . .
4.2 Desenvolvimento . . . . . .
4.3 Performance . . . . . . . . .
4.3.1 Otimiza¸˜es . . . . .
co

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

23
23
23
24
24

5 Aplica¸˜o em um sistema real
ca
5.1 HOLMES . . . . . . . . . . .
5.2 Integra¸ao HOLMES e PIP .
c˜
5.2.1 Arquitetura . . . . . .
5.2.2 Visualiza¸ao . . . . . .
c˜
5.3 Caso de Uso . . . . . . . . . .

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

28
28
28
29
30
30

6 Conclus˜o
a

33

4

Apˆndices
e

34

A Primeira Vers˜o
a

35

B Segunda Vers˜o
a

37

C Terceira Vers˜o
a

40

D Aproxima¸˜es
co

46

Referˆncias
e

47

5

Cap´
ıtulo 1
Introdu¸˜o
ca
Manter sistemas complexos em pleno funcionamento e harmonia requer constante monitora¸ao de suas partes. Datacenters, por menores que sejam, precisam ser constantemente
c˜
monitorados para garantir que seus equipamentos e servi¸os estejam dispon´
c
ıveis e em correto funcionamento. Nesses ambientes, subutiliza¸ao de recursos, per´
c˜
ıodos de inatividade
ou falhas em dispositivos s˜o situa¸˜es indesej´veis que podem levar a perdas de faturaa
co
a
mento signiﬁcativas por parte de seus mantenedores.
Para evitar tais riscos, medi¸oes sobre equipamentos e servi¸os precisam ser coletadas
c˜
c
continuamente com o objetivo de apoiar a tomada de decis˜o, tanto em n´
a
ıveis micro, onde
simples mudan¸as de dispositivos s˜o agendadas, at´ reestrutura¸oes em arquiteturas de
c
a
e
c˜
servi¸os.
c
Datacenters podem ser vistos como verdadeiras “m´quinas” de produ¸˜o de s´ries
a
ca
e
temporais. Como medi¸oes s˜o realizadas com frequˆncia, ´ natural observar nesse conc˜
a
e
e
texto, s´ries temporais com alta dimensionalidade, representados por datasets de muitos
e
´
gibibytes de aglomerados num´ricos semi-estruturados. E desej´vel, portanto, que se
e
a
tenha um meio apropriado de visualiza¸ao de dados e entre outras formas de leitura, a
c˜
visualiza¸˜o de gr´ﬁcos desempenha um papel importante.
ca
a
O prop´sito deste trabalho ´ auxiliar operadores de datacenters em sua recupera¸˜o e
o
e
ca
visualiza¸˜o de gr´ﬁcos, que representam a evolu¸˜o do comportamento de seus equipaca
a
ca
mentos e servi¸os, e para tanto foi buscada inspira¸˜o em um algoritmo utilizado para o
c
ca
reconhecimento de padr˜es em s´ries temporais do mercado ﬁnanceiro.
o
e
O algoritmo Perceptually Important Points 1 ao mesmo tempo que contribui para a
redu¸ao de dimensionalidade, fornece um mecanismo automatizado de elei¸˜o dos pontos
c˜
ca
mais importantes de uma s´rie temporal para um observador humano, favorecendo, deste
e
modo, sua visualiza¸˜o e tr´fego pela rede.
ca
a
A implementa¸ao do algoritmo e sua implanta¸ao em um sistema de monitora¸˜o de
c˜
c˜
ca
1

Preferiu-se o termo Perceptually Important Points em sua l´
ıngua inglesa por ser mais conhecido dessa
forma na literatura, al´m de oferecer o mneumˆnico e acrˆnimo PIP.
e
o
o

6

datacenters j´ existente2 , hoje utilizado por grandes datacenters do Brasil, resumem o
a
cerne deste texto.
Nas pr´ximas se¸˜es s˜o apresentadas as motiva¸˜es que fomentaram a elabora¸ao
o
co
a
co
c˜
deste trabalho, os objetivos pretendidos, a metodologia aplicada e um resumo de cada
cap´
ıtulo foi acrescentado para que o leitor possa obter uma vis˜o geral da organiza¸ao
a
c˜
deste texto.

1.1

Motiva¸˜o
ca

Softwares atuais largamente utilizados no contexto de datacenters, como RRDtool [1]
se baseiam em fun¸˜es agregadoras simples de m´dia, m´ximo ou m´
co
e
a
ınimo, que podem
deturpar a interpreta¸ao de seus gr´ﬁcos.
c˜
a
A motiva¸˜o deste trabalho ´ a de solucionar a carˆncia de um mecanismo eﬁcaz para
ca
e
e
a representa¸˜o e visualiza¸˜o de s´ries temporais em um software de monitora¸ao de
ca
ca
e
c˜
datacenters, a saber, HOLMES.
O sistema HOLMES conta com uma interface web, onde o usu´rio ﬁnal, em geral, um
a
operador de datacenter, tem a capacidade de visualizar o comportamento de um de seus
equipamentos ou servi¸os ao longo do tempo. Para tanto, o usu´rio faz requisi¸˜es HTTP
c
a
co
3
a s´ries temporais via REST .
e
Responder a essas requisi¸˜es com os dados originais pode provocar alguns problemas,
co
tais como:
• Perdas de performance causadas pelo tr´fego de milhares de pontos pela rede;
a
• Gr´ﬁcos com muitos pontos em uma area reduzida pode favorecer representa¸˜es
a
´
co
muito densas, visualmente polu´
ıdas e pouco informativas;
• Consumo de mem´ria excessivo para o usu´rio ﬁnal, dado que os pontos s˜o aro
a
a
mazenados no web browser do cliente.

1.2

Objetivos

A ﬁm de solucionar os problemas mencionados na se¸ao anterior, os objetivos tra¸ados
c˜
c
para a realiza¸ao deste trabalho incluem:
c˜
1. Implementar um algoritmo que reduza a dimensionalidade de s´ries temporais e
e
represente visualmente de modo mais ﬁel poss´ as s´ries originais;
ıvel
e
2. Integra¸˜o em um software de monitora¸ao de datacenters.
ca
c˜
2

O software citado recebe o nome de HOLMES e ser´ apresentado no cap´
a
ıtulo 5.
REST, Representational State Transfer, t´cnica de engenharia de software para sistemas hiperm´
e
ıdia
distribu´
ıdos. Comumente usada no contexto da World Wide Web.
3

7

1.3

Metodologia

Para ﬁns de execu¸˜o dos desaﬁos propostos, fez-se necess´rio o estudo e pesquisa de
ca
a
artigos e livros na area de s´ries temporais. Fundamentado nesse estudo, optou-se por
´
e
implementar o algoritmo Perceptually Important Points por ser conceitualmente simples
e atender de forma satisfat´ria no dom´
o
ınio aplicado.
Como o algoritmo escolhido apresentava complexidade de tempo O(n2 ), quest˜es de
o
performance e desempenho foram trabalhadas e viabilizar a implementa¸ao do c´digoc˜
o
fonte requereu um estudo mais aprofundado sobre a linguagem de programa¸ao Clojure.
c˜
Vale ressaltar tamb´m que desde o princ´
e
ıpio deste projeto foi vislumbrada a implanta¸˜o do algoritmo em um software de monitora¸ao de datacenters e sua arquitetura e
ca
c˜
integra¸ao com o algoritmo escolhido foi pensada e analisada durante todo o processo.
c˜

1.4

Organiza¸˜o da Monograﬁa
ca

• O cap´
ıtulo 2 contribui com um apanhado sobre o que existe na literatura sobre s´ries
e
temporais objetivando fundamentar as bases te´ricas para o desenvolvimento dos
o
pr´ximos cap´
o
ıtulos. Modelos de representa¸˜o e caracter´
ca
ısticas de s´ries temporais
e
s˜o apresentados, al´m de contextualiza¸oes com a realidade de datacenters t´
a
e
c˜
ıpicos.
• O cap´
ıtulo 3 apresenta o algoritmo Perceptually Important Points, escolhido para
implementa¸ao neste trabalho. A intui¸˜o por tr´s do m´todo ´ revelada, junto
c˜
ca
a
e
e
com seu pseudo-algoritmo, an´lise de complexidade, limita¸˜es e compara¸oes com
a
co
c˜
m´todos existentes.
e
• O cap´
ıtulo 4 exp˜e uma instˆncia do algoritmo Perceptually Important Points imo
a
plementada na linguagem Clojure. Detalhes de implementa¸˜o, caracter´
ca
ısticas do
c´digo gerado, diﬁculdades e testes de performance realizados s˜o apresentados.
o
a
• O cap´
ıtulo 5 demonstra como se realizou a integra¸ao do algoritmo descrito no
c˜
cap´
ıtulo 4 em um software de monitora¸ao de datacenters. Seu prop´sito e uma vis˜o
c˜
o
a
geral da arquitetura do sistema envolvida na integra¸ao do algoritmo ´ discutida,
c˜
e
seguida de um caso de uso de sucesso.
• Por ﬁm, no cap´
ıtulo 6 seguem as conclus˜es sobre o trabalho realizado e propostas
o
de trabalhos futuros s˜o delineadas.
a

8

Cap´
ıtulo 2
S´ries temporais
e
Na area m´dica, ´ comum a monitora¸ao da evolu¸ao de fun¸oes vitais de pacientes
´
e
e
c˜
c˜
c˜
atrav´s de aparelhos como eletroencefalogramas e eletrocardiogramas, al´m do acompane
e
hamento da incidˆncia de padr˜es sazonais de epidemias [6]. Na ciˆncia econˆmica, muitos
e
o
e
o
livros [9] e artigos [10] j´ foram escritos sobre an´lises e previs˜es do mercado ﬁnanceiro,
a
a
o
pol´
ıticas ﬁscais e monet´rias, baseadas em observa¸oes no tempo. O que a Medicina e
a
c˜
a Economia e outras ´reas supostamente n˜o correlatas possuem em comum ´ o fato de
a
a
e
permitirem a aplica¸ao de estudos e m´todos de s´ries temporais.
c˜
e
e
S´ries temporais podem ser constru´
e
ıdas sobre praticamente quaisquer medi¸˜es posco
s´
ıveis no tempo e esse car´ter gen´rico ´ o que torna a utilidade do seu estudo indiscut´
a
e
e
ıvel
em diversas ´reas do conhecimento humano. O tema ´ usado com sutis diferen¸as entre
a
e
c
matem´ticos, estat´
a
ısticos e outros proﬁssionais. Por essa raz˜o, segue a deﬁni¸ao que ser´
a
c˜
a
1
utilizada :
Deﬁni¸˜o 1. S´rie temporal: sequˆncia de observa¸oes2 ordenadas cronologicamente (nca
e
e
c˜
tupla):
S = (s1 , s2 , s3 , ..., sn )
(2.1)
Quando tais observa¸oes s˜o coletadas no tempo continuamente, diz-se que a s´rie
c˜
a
e
temporal ´ cont´nua e quando as medi¸oes se fazem em instantes de tempo espec´
e
ı
c˜
ıﬁcos,
geralmente equidistantes, s˜o conhecidas como s´ries temporais discretas.
a
e
Na ﬁgura 2.1, podemos visualizar um exemplo de s´rie temporal discreta, descrevendo
e
o pre¸o de fechamento das a¸˜es da IBM ao longo do ano de 2010.
c
co
Em geral, o estudo de s´ries temporais comporta objetivos dos mais diversos, como
e
identiﬁca¸ao de tendˆncias e outliers3 , predi¸ao, similaridade entre s´ries temporais por
c˜
e
c˜
e
clusteriza¸ao, existˆncia de sazonalidades – endere¸ado na se¸ao 2.1.3 – entre outros.
c˜
e
c
c˜
1

S´ries temporais tamb´m podem ser deﬁnidas como um conjunto de observa¸˜es {X(t), t ∈ T }, com
e
e
co
X representando a vari´vel aleat´ria observada e T um conjunto de ´
a
o
ındices.
2
Tais observa¸˜es podem ser coletadas em per´
co
ıodos regulares ou n˜o.
a
3
Observa¸˜es distantes ou discrepantes quando comparadas globalmente com outras observa¸˜es.
co
co

9

Figura 2.1: Pre¸o de fechamento de a¸oes da IBM no ano de 2010.
c
c˜
http://wolframalpha.com.

Fonte:

A seguir, ser˜o apresentadas caracter´
a
ısticas e t´cnicas envolvidas na visualiza¸ao, repe
c˜
resenta¸ao e an´lise de s´ries temporais. Ao ﬁnal deste cap´
c˜
a
e
ıtulo, contextualizaremos o
papel de s´ries temporais com a realidade de grandes datacenters.
e

2.1
2.1.1

Caracter´
ısticas
Dependˆncia de observa¸˜es
e
co

O valor das a¸oes da IBM ao ﬁnal de um dia se torna naturalmente dependente do seu
c˜
desempenho em dias anteriores. Da mesma forma, o n´mero de pessoas que habitavam o
u
planeta Terra em anos passados tem inﬂuˆncia direta sobre a popula¸˜o mundial de hoje.
e
ca
´
E comum encontrar na literatura, ressalvas sobre a aplica¸ao de muitos m´todos esc˜
e
tat´
ısticos tradicionalmente baseados na suposi¸˜o de que observa¸oes adjacentes s˜o inca
c˜
a
dependentes e identicamente distribu´
ıdas. Sendo assim, identiﬁcar a existˆncia de corree
la¸oes entre medi¸˜es no tempo ´ essencial para que possamos aplicar an´lises estat´
c˜
co
e
a
ısticas
apropriadas.

2.1.2

Alta dimensionalidade

´
E comum observar na literatura a interpreta¸ao da n-tupla descrita na deﬁni¸ao 2.1
c˜
c˜
n
como um ponto em uma espa¸o de dimens˜o
c
a
. Como novas observa¸oes s˜o coletadas
c˜
a
constantemente, s´ries temporais assumem, portanto, car´ter de alta dimensionalidade.
e
a
Como possuem centenas de milhares a milh˜es de pontos e trat´-los em sua forma bruta
o
a
se torna computacionalmente custoso, ´ desej´vel, em aplica¸˜es pr´ticas, um mecanismo
e
a
co
a
que favore¸a a redu¸ao de dimensionalidade.
c
c˜

10

2.1.3

Sazonalidade

´
E poss´ identiﬁcar na Natureza diversos fenˆmenos que possuem algum comportaıvel
o
mento sazonal. A produ¸˜o de arroz na China, o n´mero de passagens vendidas por uma
ca
u
companhia a´rea ao longo de um ano, a migra¸˜o das aves com a chegada do inverno e a
e
ca
quantidade de visitas em uma p´gina na Internet possuem no m´
a
ınimo um comportamento
em comum: sazonalidade.
No contexto de s´ries temporais, o termo sazonalidade diz respeito a padr˜es que se
e
o
repetem em per´
ıodos no tempo. Sazonalidades podem ser classiﬁcadas em dois tipos:
aditivas e multiplicativas. A primeira retrata ﬂutua¸oes que n˜o sofrem mudan¸as muito
c˜
a
c
bruscas quando considerada a s´rie globalmente. Sazonalidades multiplicativas dependem
e
de um fator em cada per´
ıodo em que ´ observada e possuem uma maior variabilidade
e
quando comparadas com a s´rie original como um todo.
e

2.1.4

Tendˆncia
e

A quantidade de agua doce no mundo vem diminuindo ao longo dos anos. Ao mesmo
´
tempo, o n´mero de artigos cient´
u
ıﬁcos publicados no meio acadˆmico cresce monotonie
camente. Tendˆncias de crescimento ou decrescimento podem ser identiﬁcadas em s´ries
e
e
temporais e podem ser caracterizadas por sua taxa de varia¸˜o. Se sua taxa de crescica
mento se aproximar de uma reta, diz-se que a s´rie possui tendˆncia linear. Caso contr´rio,
e
e
a
tendˆncias podem ser classiﬁcadas como n˜o lineares, exponenciais ou quadr´ticas.
e
a
a

(a) Sem tendˆncia
e
sazonalidade

ou

(b) Sem tendˆncia, com
e
sazonalidade

(c) Tendˆncia linear, com
e
sazonalidade aditiva

(d) Tendˆncia linear e
e
sazonalidade multiplicativa

(e) Tendˆncia n˜o linear e
e
a
sazonalidade aditiva

(f) Tendˆncia n˜o linear
e
a
e sazonalidade multiplicativa

Figura 2.2: Padr˜es de tendˆncia e sazonalidade em s´ries temporais
o
e
e

Na ﬁgura 2.2, padr˜es de comportamento relacionando sazonalidade e tendˆncia poo
e
dem ser observados. Al´m das caracter´
e
ısticas apresentadas, outras bastante utilizadas
na literatura e n˜o menos importantes s˜o estacionariedade, aleatoriedade e ciclidade. A
a
a
11

seguir, uma breve descri¸ao de t´cnicas largamente utilizadas para an´lise e compress˜o
c˜
e
a
a
de s´ries temporais.
e

2.2

Representa¸˜o e redu¸˜o de dimensionalidade
ca
ca

A representa¸˜o de s´ries temporais em sua forma original pode ser computacionalca
e
mente custosa, dada sua alta dimensionalidade – discutida na se¸ao 2.1.2. A escolha do
c˜
m´todo de representa¸ao deve se basear na aplicabilidade desejada. Existem atualmente
e
c˜
diversas abordagens para compress˜o e representa¸˜o de s´ries temporais. Algumas se
a
ca
e
baseiam em transforma¸˜es de dom´
co
ınios, como Discrete Fourier Transform, que mapeiam
para o dom´
ınio de frequˆncias uma s´rie em seu dom´
e
e
ınio temporal, outras podem preservar dois dom´
ınios, como ´ o caso de Discrete Wavelet Transform. O objetivo dessa se¸˜o
e
ca
´ apresentar as ideias das abordagens mais conhecidas e utilizadas.
e

2.2.1

Algoritmos utilizados

S´ries temporais podem ser vistas como fun¸˜es matem´ticas e como tais podem se
e
co
a
favorecer de t´cnicas b´sicas da Matem´tica Aplicada, como aproxima¸˜es de fun¸oes
e
a
a
co
c˜
complexas por fun¸oes mais simples, como retas. O m´todo conhecido como PLA (Piecec˜
e
wise Linear Approximation) segmenta uma s´rie temporal em partes e para cada uma
e
delas deﬁne a reta que mais se aproxima dos pontos no segmento considerado. Na ﬁgura
2.3 podemos ver um exemplo de como uma s´rie pode ser aproximada por esse m´todo.
e
e

Figura 2.3: Piecewise Linear Approximation

Abordagens com teor matem´tico mais apurados tamb´m s˜o utilizadas para reprea
e
a
sentar s´ries temporais. Os resultados de Jean-Baptiste Joseph Fourier, que demonstrou
e
que todo sinal peri´dico poderia ser aproximado por somas de senos e cossenos, podem
o
12

ser mapeados para o campo dos n´meros complexos, dando origem a transformada de
u
Fourier.

Figura 2.4: Compara¸ao entre algoritmos de representa¸˜o e redu¸˜o de dimensionalidade
c˜
ca
ca
de s´ries temporais.
e

A partir dessa transformada, uma s´rie temporal pode ser decomposta por suas come
ponentes no dom´ das frequˆncias. Na primeira coluna da ﬁgura 2.4 podemos ver como
ınio
e
uma aproxima¸ao pode ser feita com o algoritmo FFT (Fast Fourier Transform), uma
c˜
das variantes de uma classe maior de algoritmos baseados na transformada de Fourier,
conhecida como DFT (Discrete Fourier Transform). Uma desvantagem deste m´todo ´
e
e
que se perde o referencial de eventos no tempo.
Outro algoritmo largamente utilizado para compress˜o de imagens e que pode ser
a
utilizado para redu¸ao de dimensionalidade de s´ries temporais ´ o DWT (Discrete Wavelet
c˜
e
e
Transform), mais vantajoso do que o DFT em alguns aspectos, pois preserva componentes
no dom´ do tempo. Uma “wavelet” ou ondaleta ´ uma pequena onda que pode ser usada
ınio
e
como base para a reconstru¸˜o da s´rie original e diferente dos senos e cossenos utilizados
ca
e
no DFT n˜o podem ser fun¸˜es peri´dicas. Para a utiliza¸˜o desse algoritmo ´ necess´rio
a
co
o
ca
e
a
que se escolha previamente duas ondaletas, normalmente conhecidas como ondas m˜e ψ
a
e pai φ que devem satisfazer alguns crit´rios de ortogalidade.
e
13

Figura 2.5: Fam´ de Wavelets.
ılia

Na ﬁgura 2.5 podemos ver pares de fun¸˜es m˜e e pai que satisfazem esses crit´rios
co
a
e
e podem ser utilizadas como wavelets. Repare na segunda coluna da ﬁgura 2.4 a aproxima¸ao de uma s´rie utilizando a ondaleta Haar, reconhecida como a primeira ondaleta
c˜
e
utilizada.
Ainda na ﬁgura 2.4, pode-se observar como os m´todos apresentados e outros se come
portam para a mesma s´rie original de entrada. Em cada coluna, a s´rie original de
e
e
entrada aparece em vermelho e logo abaixo, em azul, a s´rie aproximada pelo algoritmo
e
correspondente.
Al´m dos apresentados, existem na literatura diversos algoritmos de representa¸ao e
e
c˜
redu¸ao de dimensionalidade de s´ries temporais. Alguns deles s˜o: Piecewise Constant
c˜
e
a
Approximation (PCA), Symbolic Approximation (SA), Symbolic Aggregate ApproXimation (SAX), Singular Value Decomposition (SVD), CHEByshev polynomials (CHEB) e
Self-Organizing Maps (SOM).
A partir dessa vis˜o geral sobre o atual cen´rio no que diz respeito a representa¸ao e
a
a
c˜
14

compress˜o de s´ries temporais, na pr´xima se¸ao uma contextualiza¸˜o com o ambiente
a
e
o
c˜
ca
de datacenters ser´ apresentada.
a

2.3

S´ries temporais de datacenters
e

Datacenters s˜o ambientes que concentram equipamentos de processamento e ara
mazenamento de dados de empresas ou organiza¸˜es. Podem ser considerados como
co
leg´
ıtimas “m´quinas” de produ¸˜o de s´ries temporais. Em uma instala¸˜o t´
a
ca
e
ca ıpica, s˜o
a
encontrados diversos racks de servidores centralizadores de in´meras unidades de procesu
samento e armazenamento.
O foco deste trabalho se concentra em s´ries temporais de observa¸˜es feitas sobre os
e
co
equipamentos e dispositivos desses datacenters. O operador de um grande datacenter, em
geral, precisa monitorar dados de consumo de CPU, mem´ria, sess˜es TCP abertas, reqo
o
uisi¸˜es HTTP, taxa de hits em caches, n´mero de queries lentas a bancos de dados, entre
co
u
outras m´tricas. Em datacenters possu´
e
ımos um conjunto bem heterogˆneo de padr˜es de
e
o
s´ries temporais. Na ﬁgura 2.6 podemos ver alguns exemplos de gr´ﬁcos que fazem parte
e
a
do dia a dia de opera¸ao de um datacenter.
c˜
Esses gr´ﬁcos foram gerados atrav´s de uma ferramenta bem conhecida, RRDtool.
a
e
Com essa ferramenta ´ poss´ escrever scripts para coletar informa¸oes de dispositivos
e
ıvel
c˜
de tempos em tempos. O software ´ livre e utiliza o conceito de Round Robin Database,
e
em que ´ mantido sempre uma quantidade ﬁxa de pontos de cada s´rie. Quando o limite ´
e
e
e
ultrapassado, algumas estrat´gias podem ser deﬁnidas. A mais simples de todas ´ descare
e
tar sempre os pontos mais antigos. Pode-se tamb´m conﬁgurar c´lculos de agregados,
e
a
resumindo pontos por sua m´dia, m´
e
ınimo ou m´ximo.
a
Essa abordagem nem sempre ´ satisfat´ria na busca por uma causa para uma pose
o
s´ falha em um desses equipamentos, pois m´dias em dados com variˆncia muito alta
ıvel
e
a
´ desej´vel, portanto, que se tenha uma forma eﬁciente
podem mascarar falhas graves. E
a
de visualiza¸ao que permita capturar caracter´
c˜
ısticas apresentadas nesse cap´
ıtulo, como
sazonalidades e tendˆncias. Essas observa¸oes ´ que permitir˜o coletar fatos e reorganie
c˜ e
a
zar a estrutura do datacenter para que o mesmo se mantenha em pleno funcionamento.
Para tanto, algum dos algoritmos de representa¸˜o e redu¸ao de dimensionalidade se faz
ca
c˜
necess´rio.
a
No pr´ximo cap´
o
ıtulo veremos as ideias que est˜o por tr´s do algoritmo “Perceptually
a
a
Important Points”, seguido de sua implementa¸ao e a contextualiza¸˜o com datacenters
c˜
ca
ser´ retomada no cap´
a
ıtulo 5, que retratar´ a aplica¸ao do algoritmo em um sistema real
a
c˜
de monitora¸ao.
c˜

15

(a) Consumo de CPU

(b) Tr´fego de rede
a

(c) Uso do protocolo SMPP em um roteador

Figura 2.6: Gr´ﬁcos t´
a
ıpicos no dia a dia de opera¸ao de um datacenter
c˜

16

Cap´
ıtulo 3
Perceptually Important Points
Para atingir o primeiro objetivo – proposto na se¸ao 1.2 –, escolheu-se o algoritmo
c˜
“Perceptually Important Points”, pois se mostrou conceitualmente simples em rela¸˜o aos
ca
outros m´todos apresentados no cap´
e
ıtulo anterior, al´m de favorecer uma forma eﬁcaz na
e
redu¸ao de dimensionalidade de s´ries temporais.
c˜
e

3.1

Ideia do algoritmo

A primeira proposta formal do processo de identiﬁca¸ao de “Perceptually Important
c˜
Points” foi introduzida por [2] em uma an´lise t´cnica de padr˜es para aplica¸˜es ﬁnana
e
o
co
ceiras, com ideias parecidas utilizadas em trabalhos independentes de [4] e [5]. Entretanto, n˜o ´ conhecida a utiliza¸ao dessa t´cnica para o aux´ da representa¸ao de s´ries
a e
c˜
e
ılio
c˜
e
temporais de datacenters.
O algoritmo expressa um m´todo para se deﬁnir que pontos s˜o de fato imprescind´
e
a
ıveis
e que devem ser considerados para que a plotagem do gr´ﬁco preserve sua forma original
a
para um observador humano.
Para ilustrar a ideia do algoritmo, vamos utilizar como s´rie base, uma amostra de 50
e
pontos de uma fun¸˜o seno multiplicada por um fator aleat´rio entre 0 e 5 – para incluir
ca
o
algum ru´ nos dados, ilustrada na ﬁgura 3.1a.
ıdo
Para podermos identiﬁcar os pontos mais importantes de uma s´rie, ´ preciso consider´e
e
a
la como um todo. Alguns pontos podem ser importantes em um per´
ıodo, mas completamente descart´veis quando se considera toda a sua hist´ria. Por essa raz˜o, faz parte da
a
o
a
inicializa¸ao do algoritmo incluir o primeiro e ultimo pontos da s´rie original, veja ﬁgura
c˜
´
e
3.1b.
Em sua primeira itera¸ao, calculamos a distˆncia de todos os pontos no intervalo
c˜
a
com rela¸ao aos primeiros pontos escolhidos na inicializa¸ao. O ponto que possuir maior
c˜
c˜
distˆncia dos dois primeiros ser´ o pr´ximo ponto a ser promovido a PIP.
a
a
o
Ap´s a primeira itera¸˜o, processamos todas as distˆncias, agora para os dois intervalos
o
ca
a
impl´
ıcitos pelos 3 pontos j´ escolhidos. Escolhemos nessa itera¸˜o o ponto que possui a
a
ca
17

maior distˆncia desses intervalos e o promovemos a PIP. O processo se repete at´ que
a
e
todos os pontos sejam escolhidos e estejam devidamente ordenados.
Outros procedimentos e condi¸oes de parada podem ser deﬁnidos, como por exemplo,
c˜
um valor ﬁxo para o n´mero de pontos a serem escolhidos, ou a atribui¸˜o de um erro
u
ca
toler´vel. Tais condi¸˜es ser˜o discutidas ainda neste cap´
a
co
a
ıtulo na se¸ao 3.3.
c˜

(a) S´rie original com 50 pontos.
e

(b) Inicializa¸˜o.
ca

(c) 5 PIPs.

(d) 10 PIPs.

(e) 20 PIPs.

Figura 3.1: Evolu¸ao do algoritmo PIP
c˜

18

Na ﬁgura 3.1, conseguimos representar com 20 dos 50 pontos originais (descarte de 60
% dos dados originais) a s´rie com boa precis˜o visual, quase se confundindo com a s´rie
e
a
e
original para um observador humano. Compress˜es ainda melhores podem ser alcan¸adas
o
c
dependendo da forma geral da s´rie considerada. No apˆndice D, pode-se visualizar a
e
e
representa¸ao de uma s´rie original de um mˆs de dados, com 8582 pontos sendo reduzida
c˜
e
e
para apenas 300 pontos (descarte de aproximadamente 99.97% dos pontos originais), com
uma boa aproxima¸˜o visual.
ca

3.2

C´lculo de distˆncias
a
a

Em [3] s˜o apresentados testes comparativos com trˆs abordagens diferentes para o
a
e
c´lculo de distˆncias entre pontos: distˆncia vertical, distˆncia perpendicular e distˆncia
a
a
a
a
a
euclidiana. Constatou-se que a distˆncia vertical apresentava os melhores resultados, e
a
portanto, foi a escolhida para este trabalho.
Na ﬁgura 3.2 podemos capturar a ideia por tr´s do c´lculo da distˆncia vertical. Os
a
a
a
pontos P 1 e P 2 representam PIPs previamente escolhidos e o ponto P 3 um candidato
a ser promovido a PIP. Este m´todo incorpora a intui¸ao de que ﬂutua¸˜es verticais s˜o
e
c˜
co
a
mais importantes para um observador humano.
Em termos pr´ticos, ´ utilizada a equa¸ao 3.1 para calcular a distˆncia entre pontos no
a
e
c˜
a
algoritmo. Podem ser utilizadas t´cnicas de geometria anal´
e
ıtica para se chegar na equa¸ao
c˜
3.1 para o c´lculo de distˆncia vertical.
a
a
V D(p3 , pc ) =| y3 − yc |=|

y1 + (y2 − y1 )

x3 − x1
x2 − x 1

Figura 3.2: Distˆncia vertical.
a

19

− y3 |

(3.1)

3.3

Pseudo-algoritmo

Pseudo-algoritmos tem seu papel fundamental em estabelecer as macro opera¸oes que
c˜
devem ser realizadas para a resolu¸˜o de um problema, independente de linguagem de proca
grama¸ao, facilitando o entendimento do leitor e o endere¸amento de algumas observa¸˜es
c˜
c
co
sobre o m´todo.
e
A entrada do algoritmo esperada ´ uma lista de pontos da s´rie temporal original. Sua
e
e
sa´ ´ um subconjunto desses pontos, que supostamente deveriam ser os mais signiﬁcaıda e
tivos para um observador humano.
Nas linha 1 e 2 inicializamos a lista de PIPs com o primeiro e ultimo pontos da
´
s´rie. O bloco delimitado pelas linhas 3 a 6 itera sobre os pontos de entrada procurando
e
pelo pr´ximo ponto mais signiﬁcativo a cada itera¸˜o. E importante perceber que a cada
o
ca ´
itera¸˜o s˜o promovidos a PIP apenas um ponto, pois devemos considerar s´ries temporais
ca a
e
por inteiro para n˜o cair em ´timos locais.
a
o
Algorithm 1 Pseudo-algoritmo Perceptually Important Points
Require: Lista de pontos da s´rie original IN P U T [1..n] ordenada
e
Ensure: Lista de PIPs P IP [1..n]
1: P IP [1] ⇐ IN P U T [1]
2: P IP [2] ⇐ IN P U T [n]
3: repeat
4:
Selecionar ponto P − M AX de IN P U T com maior distˆncia a pontos adjacentes
a
da lista de PIPs.
5:
Inserir P − M AX em P IP
6: until tenham sido escolhidos n pontos de IN P U T [1..n]
7: return P IP
O pseudo-algoritmo 1 retorna sempre a mesma lista com todos os pontos originais,
ainda que a ordem com que sejam escolhidos os pontos revele a importˆncia de cada ponto,
a
a resposta ´ sempre a mesma, a s´rie original. Pequenos ajustes podem ser considerados
e
e
para deixar o algoritmo mais util em termos pr´ticos. Um deles ´ deﬁnir uma condi¸ao
´
a
e
c˜
de parada para retornar apenas os k <= n pontos mais importantes, exempliﬁcado pelo
pseudo-algoritmo 2.

3.3.1

An´lise de Complexidade
a

Pelo pseudoalgoritmo 1, podemos observar que as linhas 1, 2 e 7 s˜o executadas em
a
tempo constante. Para ﬁns de an´lise de complexidade podemos portanto, elimin´-las do
a
a
c´lculo. O bloco delimitado pelas linhas 3 a 6 representam o maior tempo de computa¸˜o
a
ca
e por isso devemos analis´-lo com mais cuidado.
a
Na linha 4 s˜o selecionados pontos com maior distˆncia a pontos adjancentes da lista
a
a
atual de PIPs. Como a cada itera¸ao s˜o promovidos a PIP apenas um ponto e na inicialc˜ a
20

Algorithm 2 Pseudo-algoritmo Perceptually Important Points 2
Require: Lista de pontos da s´rie original IN P U T [1..n] ordenada
e
Require: k pontos a serem escolhidos
Ensure: Lista de PIPs P IP [1..k]
1: P IP [1] ⇐ IN P U T [1]
2: P IP [2] ⇐ IN P U T [n]
3: repeat
4:
Selecionar ponto P − M AX de IN P U T com maior distˆncia a pontos adjacentes
a
da lista de PIPs.
5:
Inserir P − M AX em P IP
6: until tenham sido escolhidos k pontos de IN P U T [1..n]
7: return P IP
iza¸ao j´ escolhemos dois destes – primeiro e ultimo da s´rie original – s˜o selecionados a
c˜ a
´
e
a
cada itera¸ao, (n − 2, n − 3, n − 4, ..., 3, 2, 1) pontos para compara¸˜o de distˆncias.
c˜
ca
a
Inserir o ponto promovido a PIP na itera¸ao corrente, linha 5, pode ser considerada
c˜
constante, dependendo da estrutura de dados que se utiliza1 .
Sendo assim, a complexidade do algoritmo ´ dada pelo n´mero de c´lculos de distˆncias
e
u
a
a
que fazemos no total, e pode ser calculado como:
n−2

i=
i=1

n2 − 3n + 2
2

Deste modo, a complexidade do algoritmo ´ dada por O(n2 ). J´ para o pseudoe
a
algoritmo 2, o mesmo racioc´
ınio pode ser tra¸ado e sua complexidade de tempo ´ O(nk).
c
e

3.4

C´lculo de erro
a

Como destacado na se¸˜o 3.3, pequenas variantes do pseudo-algoritmo apresentado
ca
podem ser implementadas para solucionar algumas diﬁculdades. Para o pseudo-algoritmo
2 ´ preciso escolher como entrada o n´mero k de pontos que se deseja resgatar da s´rie
e
u
e
original. Normalmente a escolha desse valor n˜o gera bons resultados sem o conhecimento
a
a priori da s´rie original.
e
Em geral, o valor de k que representa razoavelmente bem2 a s´rie original n˜o depende
e
a
do valor de n. Para ilustrar tal aﬁrma¸ao, podemos visualizar a ﬁgura 3.3. Na s´rie
c˜
e
da ﬁgura 3.3a, um n´mero maior de pontos s˜o necess´rios para represent´-la quando
u
a
a
a
comparamos com a ﬁgura 3.3b, uma s´rie mais bem comportada; ainda que as duas
e
possuam a mesma quantidade de pontos no total, no caso 100.
Sendo assim, como n˜o ´ razo´vel que a entrada do valor de k seja feita manualmente,
a e
a
1

Para a implementa¸˜o, explicada com mais detalhes no pr´ximo cap´
ca
o
ıtulo, as inser¸˜es s˜o na verdade
co
a
O(log32 n), pois foi preferida a utiliza¸˜o de hashsets, mas que na pr´tica pode ser considerado constante.
ca
a
2
Como razoavelmente bem, busca-se o conceito subjetivo de similaridade entre duas s´ries temporais.
e

21

(a) S´rie com 100 pontos, variˆncia muito(b) S´rie com 100 pontos, baixa variˆncia
e
a
e
a
alta

Figura 3.3: S´ries com o mesmo n´mero de pontos podem necessitar de valores bem
e
u
distintos de PIPs para serem representadas visualmente de modo satisfat´rio.
o
Algorithm 3 Pseudo-algoritmo Perceptually Important Points 3
Require: Lista de pontos da s´rie original IN P U T [1..n] ordenada
e
Require: Limite m´ximo m de pontos a serem escolhidos
a
Require: Erro aceit´vel
a
Ensure: Lista de PIPs P IP [1..s], com s <= m
1: P IP [1] ⇐ IN P U T [1]
2: P IP [2] ⇐ IN P U T [n]
3: repeat
4:
Selecionar ponto P − M AX de IN P U T com maior distˆncia a pontos adjacentes
a
da lista de PIPs.
5:
Inserir P − M AX em P IP
6: until m pontos de IN P U T [1..n] j´ foram escolhidos ou tenha sido alcan¸ada uma
a
c
diferen¸a menor que
c
7: return P IP
´ desej´vel um mecanismo automatizado de inferˆncia sobre o menor valor de k necess´rio
e
a
e
a
para preservar a forma geral da s´rie original. Para tanto, podem ser utilizadas diferen¸a
e
c
de m´
ınimos quadrados a cada itera¸ao do algoritmo, dando origem ao pseudo-algoritmo
c˜
3.

3.5

Limita¸oes do algoritmo
c˜

O algoritmo d´ mais importˆncia para as grandes ﬂutua¸˜es em detrimento de varia
a
co
a¸oes mais suaves. O n´mero de pontos m´
c˜
u
ınimo necess´rios para representar razoavela
mente bem uma s´rie est´ diretamente ligado com o n´mero de picos e vales que a s´rie
e
a
u
e
possui. Para s´ries com muitos picos e vales com alta amplitude, o algoritmo n˜o consegue
e
a
uma redu¸ao de dimensionalidade signiﬁcativa.
c˜

22

Cap´
ıtulo 4
Implementa¸˜o do algoritmo
ca
Neste cap´
ıtulo s˜o apresentadas as ferramentas e t´cnicas utilizadas para a implea
e
menta¸ao do algoritmo, testes de performance realizados, diﬁculdades encontradas e a
c˜
evolu¸ao da implementa¸˜o durante seu processo de desenvolvimento.
c˜
ca

4.1

Clojure

Clojure ´ uma linguagem de prop´sitos gerais, dinˆmica e funcional, lan¸ada em 2007,
e
o
a
c
1
por Rich Hickey. Por se tratar de um dialeto de Lisp , Clojure foi criada com o intuito
de preservar o car´ter funcional e poderoso de Lisp para resolver problemas atuais como
a
concorrˆncia e paralelismo numa roupagem mais moderna.
e
Como se trata de uma implementa¸˜o do paradigma funcional, a computa¸ao dos dados
ca
c˜
´ encarada como avalia¸˜es de fun¸˜es matem´ticas, que favorecem o fraco acoplamento
e
co
co
a
entre m´dulos e incentiva o uso de recurs˜es evitando efeitos colaterais, uma vez que dados
o
o
s˜o considerados imut´veis nessas linguagens.
a
a
Para este trabalho foi utilizada a ultima implementa¸˜o est´vel2 da linguagem Clojure
´
ca
a
no momento da escrita deste texto.

4.2

Desenvolvimento

Preocupa¸oes como performance e corretude permearam o processo e t´cnicas de dec˜
e
3
senvolvimento ´gil como TDD (Test Driven Development) foram utilizadas durante sua
a
1

Lisp (LISt Processing) teve sua primeira especiﬁca¸˜o em 1958 e foi originalmente pensada como
ca
uma nota¸˜o matem´tica pr´tica para programas de computador, inﬂuenciada pelo C´lculo-λ de Alonzo
ca
a
a
a
Church. A linguagem ainda ´ uma das linguagens mais antigas ainda utilizadas largamente no momento
e
da escrita deste texto.
2
´
Foi utilizada a vers˜o 1.2, dispon´
a
ıvel em http://clojure.org/downloads. Ultimo acesso em 20 de
novembro de 2010.
3
Test Driven Development consiste em um processo de desenvolvimento de software em que testes s˜o
a
escritos antes do desenvolvimento do c´digo em si, facilitando o entendimento e condu¸˜o do processo de
o
ca
racioc´
ınio sobre o problema, al´m de contribuir como documenta¸˜o do c´digo.
e
ca
o

23

execu¸˜o.
ca
Todas as fun¸oes criadas acompanham testes unit´rios. Tais testes n˜o garantem
c˜
a
a
totalmente que o c´digo ´ correto, mas oferecem um meio de assegurar que alguns casos
o
e
previamente pensados em que o algoritmo poderia falhar est˜o cobertos e uma garantia
a
maior pode ser dada para futuros usu´rios e mantenedores do c´digo.
a
o
Nenhuma particularidade do sistema em que foi incorporado este algoritmo – descrito
no cap´
ıtulo 5 – foi inclu´ na implementa¸ao. Deste modo, o mesmo c´digo pode ser
ıda
c˜
o
encarado como uma caixa preta e pode ser incorporado em outro sistema com facilidade.
Como a linguagem Clojure ´ compilada para a JVM (Java Virtual Machine), o c´digo
e
o
tamb´m pode ser executado na maioria dos sistemas operacionais existentes atualmente.
e

4.3

Performance

Apesar do algoritmo apresentado no cap´
ıtulo 3 n˜o representar muitas diﬁculdades de
a
entendimento, implement´-lo de uma forma eﬁciente requereu pesquisa sobre as estruturas
a
de dados adequadas e detalhes da linguagem para a realiza¸ao da tarefa.
c˜
A implementa¸ao do c´digo passou por diversas modiﬁca¸oes para atender aos requic˜
o
c˜
sitos de performance exigidos pelo projeto. Foram desenvolvidas trˆs vers˜es – inclu´
e
o
ıdas
no Apˆndice – e suas evolu¸˜es ser˜o brevemente descritas na pr´xima se¸ao.
e
co
a
o
c˜

4.3.1

Otimiza¸oes
c˜

Vers˜o 1
a
A primeira vers˜o do algoritmo – A – foi desenvolvida sem grandes otimiza¸oes. N˜o
a
c˜
a
foi utilizado nenhum mecanismo de cache de resultados intermedi´rios, nem testes muito
a
robustos.
Nesta vers˜o foram deﬁnidas as estruturas de dados a serem utilizadas. Para a lista de
a
entrada, se preferiu utilizar vectors, que possuem complexidade O(1) para acesso aleat´rio.
o
Durante o processamento, mant´m-se um vector que cresce a cada itera¸ao, com os ´
e
c˜
ındices
na s´rie original para os PIPS escolhidos. Como durante o processamento, s˜o armazenae
a
dos apenas os ´
ındices – ao inv´s da combina¸˜o (x, y) de cada ponto – ao se calcular as
e
ca
distˆncias s˜o necess´rios acessos aleat´rios a s´rie original para se buscar os pontos. A
a
a
a
o
e
cada itera¸ao, o vector de PIPs ´ ordenado.
c˜
e
Como os tempos de execu¸ao apresentados ﬁcaram bem aqu´m do desejado, a implanc˜
e
ta¸˜o em um software real – um dos objetivos pretendidos com esse trabalho, apresentados
ca
na se¸ao 1.2 – se tornou impeditiva. Foi necess´rio, portanto, o desenvolvimento de uma
c˜
a
vers˜o mais robusta.
a

24

Vers˜o 2
a
Para a segunda vers˜o foram implementadas algumas melhorias. A mais importante
a
de todas se deveu a percep¸ao de que c´lculos de distˆncia eram repetidos desnecessariac˜
a
a
mente. Foi buscada, deste modo, uma solu¸ao de cacheamento dos resultados e para tanto,
c˜
utilizou-se a fun¸ao memoization da linguagem Clojure, que contribuiu para a melhora
c˜
signiﬁcativa no tempo de execu¸ao.
c˜
A cada itera¸˜o s˜o armazenados os intervalos entre pips em um hashset. A vantagem
ca a
de se armazenar os intervalos ´ que os mesmos podem ser avaliados em paralelo – depene
dendo de uma sincroniza¸ao no t´rmino para se analisar a melhor distˆncia – apesar de
c˜
e
a
n˜o ter se utilizado nenhuma esp´cie de paralelismo nessa vers˜o. Com essa altera¸ao, a
a
e
a
c˜
necessidade de se ordenar a lista de PIPs a cada itera¸˜o passou a inexistir.
ca
A escolha de um hashset se deve a dois motivos. O primeiro deles ´ que se pode garantir
e
que se a entrada possuir pontos duplicados, estes n˜o aparecer˜o na sa´ do algoritmo.
a
a
ıda
O segundo motivo ´ que como os intervalos s˜o divididos a cada itera¸ao, precisamos
e
a
c˜
redeﬁnir a lista de intervalos, retirando o intervalo anterior, criando dois novos intervalos,
no ponto em que o novo PIP foi encontrado. Acessos aleat´rios em hashsets ocorrem em
o
tempo O(log32 n), que na pr´tica pode ser considerado constante.
a
Como s˜o processadas listas muito extensas e sua avalia¸ao pode ser custosa, optou-se
a
c˜
4
tamb´m nesta vers˜o por se utilizar lazy sequences . Como muitos programas escritos
e
a
em Clojure envolvem computa¸ao de listas, a linguagem fornece esse mecanismo para
c˜
se construir express˜es complexas e extensas que s´ s˜o avaliadas quando realmente s˜o
o
o a
a
necess´rias. Listas inﬁnitas podem ser deﬁnidas com esse recurso.
a
Outra melhoria surgida nessa vers˜o se deu ainda com rela¸˜o ao c´lculo de distˆna
ca
a
a
cias. Como s˜o efeituados muitos c´lculos de distˆncias, foi buscada nessa vers˜o uma
a
a
a
a
implementa¸ao mais eﬁciente. Para isso, substituiu-se o uso da fun¸ao abs do pacote
c˜
c˜
clojure.contrib.generic.math-functions pela vers˜o mais perform´tica da fun¸ao
a
a
c˜
abs, do pacote clojure.contrib.math.
Como Clojure ´ uma linguagem constru´ por cima da linguagem Java, casting para
e
ıda
tipos primitivos para esta linguagem – discutido em [14] [cap´
ıtulo 14], – tamb´m foram
e
adicionados.
Vers˜o 3
a
A vers˜o 3, ultima desenvolvida, ´ a que oferece o menor tempo de execu¸ao dentre
a
´
e
c˜
todas as anteriores. Ao inv´s de deﬁnirmos nossas lazy sequences, foi preferida a utilizae
¸ao da fun¸ao iterate, dispon´
c˜
c˜
ıvel no core da linguagem. A fun¸ao iterate recebe como
c˜
parˆmetro uma fun¸ao e um parˆmetro adicional. No momento de sua chamada, a fun¸ao
a
c˜
a
c˜
passada como argumento ´ executada com o argumento adicional e a sua sa´ ´ aplie
ıda e
4

Para maiores detalhes sobre o conceito de lazy sequences, veja [13]

25

cada a mesma fun¸˜o. O comportamento pode ser continuado indeﬁnidamente. Isso evita
ca
muitas trocas de contexto e avalia¸oes de listas muito extensas previamente.
c˜
Fez-se uso de mais lazy sequences onde necess´rio e ganhos de performance consida
er´veis foram conseguidos quando casting para tipos primitivos foram acrescentados no
a
c´digo.
o
Testes de performance
Para comparar a evolu¸ao das implementa¸oes foram executadas as trˆs vers˜es em
c˜
c˜
e
o
ambiente controlado para s´ries aleat´rias e comparados seus tempos de execu¸˜o.
e
o
ca
A m´quina utilizada possui as seguintes conﬁgura¸oes:
a
c˜
• Processador: Intel Celeron processor 560, 2.13 GHz, 1 MiB L2 cache
• Mem´ria Principal: 1 GiB
o
• Sistema Operacional: Ubuntu Linux vers˜o 10.04
a
Na tabela 4.1 ´ poss´ ver um resumo dos tempos de execu¸ao para testes realizados
e
ıvel
c˜
com s´ries aleat´rias – para n˜o privilegiar nenhuma das vers˜es – de 100 pontos e 1000
e
o
a
o
pontos. Foram executadas 500 rodadas para cada valor de PIPs e tirada sua m´dia para
e
atender a Lei dos Grandes N´meros e garantir uma baixa variˆncia nos resultados. Podeu
a
se observar que a Vers˜o 1 distoa bastante das outras duas vers˜es.
a
o

N´mero de
u
4
10
20
30
40
50
60
70
80
90

Tempos de execu¸ao
c˜
PIPs Vers˜o 1
a
Vers˜o 2
a
7.49943 1.8605996
26.238653 2.321418
54.226994 4.5783596
84.99333 5.6005797
115.92436 7.35721
145.32526 9.438611
156.99683 12.641098
171.61131 14.659222
174.81184 15.915979
189.28699 18.447191

Vers˜o 3
a
0.6156479
1.0887681
1.3933954
2.06694
3.0876982
3.6283286
4.9837728
5.6078625
7.315132
8.141004

Tabela 4.1: Tempos de execu¸˜o para as trˆs vers˜es implementadas do algoritmo PIP
ca
e
o
para s´ries com 100 pontos. Os tempos est˜o em milissegundos.
e
a
´
E poss´ observar tamb´m que a Vers˜o 3 ´ duas vezes mais r´pida que a Vers˜o 2
ıvel
e
a
e
a
a
analisando os valores da tabela 4.2. Um ganho consider´vel de performance quando s´ries
a
e
com alta dimensionalidade devem ser processadas. Nas ﬁguras 4.1a e 4.1b, podem ser
vistos os mesmos dados de forma gr´ﬁca.
a
26

Tempos
N´mero de PIPs
u
100
200
300
400
500
600
700
800
900

de execu¸ao
c˜
Vers˜o 2
a
Vers˜o 3
a
239.5926 101.20084
342.2604 184.52263
396.32697 163.0423
538.5814 217.53302
706.6794 328.58374
952.6192 394.18314
1071.5186 481.18253
1279.3595 561.9523
1397.1849 708.9733

Tabela 4.2: Tempos de execu¸˜o para as duas melhores vers˜es implementadas do algoca
o
ritmo PIP para s´ries com 1000 pontos. Os tempos est˜o em milissegundos.
e
a

(a) Compara¸˜o entre os tempos de execu¸˜o das trˆs
ca
ca
e
vers˜es implementadas. S´rie original possu´ 100
o
e
ıa
pontos.

(b) Compara¸˜o entre os tempos de execu¸˜o das
ca
ca
duas melhores vers˜es implementadas. S´rie original
o
e
possu´ 1000 pontos.
ıa

Figura 4.1: Tempos de execu¸˜o para as implementa¸oes do algoritmo PIP
ca
c˜

27

Cap´
ıtulo 5
Aplica¸˜o em um sistema real
ca
O objetivo da implementa¸˜o do algoritmo apresentado no cap´
ca
ıtulo 4 foi permitir sua
implanta¸ao no sistema de monitora¸˜o de datacenters HOLMES, brevemente descrito
c˜
ca
neste cap´
ıtulo.
A integra¸ao com o algoritmo PIP e a arquitetura do software envolvida tamb´m s˜o
c˜
e
a
discutidas. Ademais, o resultado ﬁnal ´ apresentado e em seguida um caso de uso de
e
sucesso ´ apresentado.
e

5.1

HOLMES

O dia a dia da equipe de opera¸ao de um datacenter envolve entre outras atividades,
c˜
o acompanhamento em tempo real de informa¸oes provenientes de diferentes m´quinas e
c˜
a
dispositivos. Centenas de m´tricas precisam ser monitoradas para garantir que o sistema
e
n˜o apresente quedas de servi¸o ou downtime, onde na maioria dos casos pode provocar
a
c
perdas signiﬁcativas de faturamento para o mantenedor do datacenter e seu neg´cio.
o
O software HOLMES foi criado com o prop´sito de fornecer aos operadores de dataceno
ters ferramentas para an´lise e monitoramento de informa¸oes em tempo real, favorecendo
a
c˜
o aumento de sua consciˆncia situacional, fator cr´
e
ıtico em um ambiente em que muitos
equipamentos precisam ser monitorados e a correla¸˜o entre eventos para a resolu¸ao de
ca
c˜
um dado problema pode ser dif´ mesmo para operadores experientes.
ıcil,

5.2

Integra¸˜o HOLMES e PIP
ca

Dentre outras funcionalidades, o software possui uma interface de visualiza¸ao de
c˜
gr´ﬁcos. Nessa interface ´ poss´ inspecionar gr´ﬁcos de m´tricas coletadas ao longo do
a
e
ıvel
a
e
tempo provenientes dos itens de conﬁgura¸ao cadastrados pelos usu´rios do sistema.
c˜
a
O termo item de conﬁgura¸˜o ´ origin´rio da terminologia ITIL e pode representar
ca e
a
um dispositivo f´
ısico como roteador, disco r´
ıgido, unidade de processamento, ou qualquer

28

outra m´trica l´gica como protocolo TCP/IP, HTTP, etc.
e
o
Itens de conﬁgura¸ao s˜o, em geral, cadastrados no sistema pela equipe de operadores
c˜ a
do datacenter. Uma vez cadastrados e conﬁgurados, os itens de conﬁgura¸ao passam a
c˜
emitir eventos para um barramento central, de onde s˜o coletados e armazenados. Com
a
base nesses eventos, podemos construir suas s´ries temporais em sua forma mais bruta.
e
Devido a propriedade de alta dimensionalidade, essas s´ries requerem um processae
mento adicional antes de serem entregues efetivamente para o usu´rio ﬁnal, na interface
a
´ nesta fase que o algoritmo PIP ´ empregado, com o papel de rede visualiza¸ao. E
c˜
e
duzir a dimensionalidade dos dados originais e oferecer uma visualiza¸˜o que preserva o
ca
comportamento e a forma do gr´ﬁco da s´rie original.
a
e

5.2.1

Arquitetura

O software de monitora¸˜o HOLMES possui um barramento central – m´dulo Message
ca
o
broker na ﬁgura 5.1 – destino dos eventos provenientes de diversos equipamentos. Esses
dados s˜o coletados e enviados para um m´dulo de armazenamento denominado storage,
a
o
ilustrado na ﬁgura 5.1.
Na ﬁgura 5.1 ´ demonstrada a arquitetura geral do sistema HOLMES, com destaque
e
para os m´dulos envolvidos na integra¸ao.
o
c˜

Figura 5.1: Arquitetura do sistema HOLMES e m´dulos participantes da integra¸ao com
o
c˜
o algoritmo PIP

Quando um usu´rio ﬁnal requisita uma s´rie temporal atrav´s da interface web do sisa
e
e
tema HOLMES, o m´dulo storage ´ ativado. Os dados originais s˜o coletados e entregues
o
e
a
29

para processamento pelo algoritmo PIP, devolvidos em seu t´rmino1 para o web browser
e
do cliente.
A partir dos pontos perceptivelmente mais importantes no web browser do cliente,
seus pontos s˜o entregues ﬁnalmente a uma biblioteca Javascript para a plotagem ﬁnal.
a
Essa estrat´gia evita que pela rede sejam trafegados todos os pontos originais das s´ries
e
e
temporais requisitadas.
Al´m disso, ainda que n˜o existissem problemas de banda no tr´fego de todos os pone
a
a
tos, outra diﬁculdade surgiria na etapa de plotagem dos gr´ﬁcos, no que diz respeito a
a
densidade de pontos. O algoritmo PIP resolve de forma satisfat´ria essas duas diﬁculo
dades.

5.2.2

Visualiza¸˜o
ca

Para ilustrar o resultado ﬁnal do que foi exposto at´ aqui, alguns screenshots foram
e
tirados do sistema HOLMES, que ´ apenas um codinome para o sistema real: Intelie
e
Event Manager.
As s´ries temporais que s˜o exibidas para o usu´rio ﬁnal est˜o organizadas na area
e
a
a
a
´
Hist´rico do sistema. Na ﬁgura 5.2, ´ poss´ observar alguns gr´ﬁcos utilizando o alo
e
ıvel
a
goritmo PIP. Como o sistema ´ comercial, alguns nomes foram borrados para manter
e
privacidade de seus clientes. Repare que segundo descrito na se¸˜o 3.5, o algoritmo PIP
ca
n˜o se comporta muito bem com muitos picos e vales, mas ainda assim apresenta resula
tados satisfat´rios quando o n´mero de PIPs ´ suﬁciente, como pode ser observado na
o
u
e
ﬁgura 5.2b.

5.3

Caso de Uso

O sistema HOLMES est´ em uso atualmente em dois grandes datacenters do Brasil:
a
globo.com e iG.
Vers˜es anteriores do sistema HOLMES contavam com t´cnicas de m´dia sobre m´o
e
e
e
dia, brevemente discutidas na se¸ao 2.3, que desﬁguravam a forma geral do gr´ﬁco, conc˜
a
fundindo usu´rios ﬁnais em sua interpreta¸ao dos dados.
a
c˜
Operadores destes datacenters manifestaram diminui¸ao no tempo de detec¸ao de falc˜
c˜
has de problemas em equipamentos de seus servidores ap´s a implementa¸˜o da interface
o
ca
de visualiza¸ao utilizando o algoritmo PIP.
c˜

1

Os dados s˜o devolvidos em formato JSON (JavaScript Object Notation), formato de serializa¸˜o de
a
ca
dados largamente utilizado na Internet.

30

(a) Load m´
ınimo nos ultimos 15 minutos
´

(b) Tempo de resposta do protocolo TCP

Figura 5.2: Gr´ﬁcos gerados a partir do algoritmo PIP no sistema HOLMES
a

31

(a) Load m´
ınimo nos ultimos 15 minutos
´

(b) Tempo de resposta do protocolo TCP

Figura 5.3: Gr´ﬁcos gerados a partir do algoritmo PIP no sistema HOLMES
a

32

Cap´
ıtulo 6
Conclus˜o
a
Com o aumento da capacidade de processamento e armazenamento das m´quinas
a
seguindo a Lei de Moore, a possibilidade de se lidar com s´ries temporais cada vez maiores
e
vem crescendo ao longo dos anos. A literatura existente sobre o assunto ´ extremamente
e
vasta e rica, com aplica¸oes nos mais variados campos do conhecimento humano.
c˜
O algoritmo escolhido para esse trabalho tem sido usado em s´ries temporais do mere
cado ﬁnanceiro e aplica¸oes no dom´
c˜
ınio de datacenters ´ nova at´ onde foi poss´
e
e
ıvel se
investigar.
A relevˆncia deste trabalho se manifesta a partir da aprova¸ao por parte dos usu´rios
a
c˜
a
do sistema HOLMES, com relatos conﬁrmando a diminui¸˜o no tempo de identiﬁca¸ao e
ca
c˜
solu¸ao de problemas em ambientes de opera¸˜o de datacenters.
c˜
ca
Apesar dos objetivos deﬁnidos para este trabalho – expostos na se¸˜o 1.2 – terem sido
ca
alcan¸ados com ˆxito, muitas melhorias no software ainda se fazem necess´rias; como um
c
e
a
mecanismo para o c´lculo de erro e escolha automatizada do n´mero m´
a
u
ınimo de pontos –
descritos na se¸ao 3.4 – para representar a s´rie temporal original, n˜o inclu´ na vers˜o
c˜
e
a
ıda
a
ﬁnal da implementa¸ao devido o fator tempo.
c˜
Por ﬁm, pode-se endere¸ar a trabalhos futuros, a integra¸ao com outros algoritmos de
c
c˜
representa¸ao e redu¸ao de dimensionalidade na tentativa de se reduzir as limita¸˜es do
c˜
c˜
co
algoritmo “Perceptually Important Points”, al´m de testes comparativos mais extensos no
e
dom´
ınio de datacenters.

33

Apˆndices
e

34

Apˆndice A
e
Primeira Vers˜o
a
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32

;
;
;
;

Implementation of P e r c e p t u a l l y Important Points algorithm
Author : Ronald Andreu K a i s e r
First version
L a s t Updated : Sat 20 Nov 2010 0 5 : 0 4 : 0 5 PM BRST

( ns p i p
( : r e q u i r e [ c l o j u r e . c o n t r i b . g e n e r i c . math−functions : a s math ] ) )

( defn v e r t i c a l − d i s t a n c e
[ [ x1 y1 ] [ x3 y3 ] [ x2 y2 ] ]
( math/abs (− (+ y1 ( ∗ (− y2 y1 ) ( / (− x3 x1 ) (− x2

x1 ) ) ) ) y3 ) ) )

( d e f n max−distance−in−interval
[ o r i g i n a l − s e r i e first−pip−index last−pip−index ]
( l e t [ p1 ( o r i g i n a l − s e r i e f i r s t − p i p − i n d e x )
p2 ( o r i g i n a l − s e r i e l a s t − p i p − i n d e x ) ]
( reduce
( f n [ c u r r e n t − b e s t ca ndida te−po int−index ]
( l e t [ c u r r e n t − d i s t a n c e ( v e r t i c a l − d i s t a n c e p1 ( o r i g i n a l − s e r i e
ca ndida te−po int−index ) p2 ) ]
( i f (> c u r r e n t − d i s t a n c e ( f i r s t c u r r e n t − b e s t ) )
[ c u r r e n t − d i s t a n c e ca ndida te−po int−index ]
current−best ) ) )
[−1 −1] ( r a n g e (+ f i r s t − p i p − i n d e x 1 ) l a s t − p i p − i n d e x ) ) ) )

( d e f n next−pip−index
[ o r i g i n a l − s e r i e current−pips ]
( second ( f i r s t
( reduce

35

33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61

( fn [ [ [ last−best−distance last−best−index ] left−pip−index ]
right−pip−index ]
( i f (> (− right−pip−index l e f t − p i p − i n d e x ) 1 )
( l e t [ b e s t − c u r r e n t ( max−distance−in−interval o r i g i n a l − s e r i e
l e f t − p i p − i n d e x right−pip−index ) ]
( i f (> ( f i r s t b e s t − c u r r e n t ) l a s t − b e s t − d i s t a n c e )
[ b e s t − c u r r e n t rig ht−pip−index ]
[ [ l a s t − b e s t − d i s t a n c e l a s t − b e s t − i n d e x ] right−pip−index ] ) )
[ [ l a s t − b e s t − d i s t a n c e l a s t − b e s t − i n d e x ] right−pip−index ] ) )
[ [ − 1 0 ] 0 ] ( vec ( r e s t c u r r e n t − p i p s ) ) ) ) ) )

( d e f n new−pip−seq
[ o r i g i n a l − s e r i e current−pips ]
( vec ( s o r t ( c o n j c u r r e n t − p i p s ( next−pip−index o r i g i n a l − s e r i e c u r r e n t − p i p s
)))))

( d e f n format−output
[ o rigina l−se rie pips ]
( vec (map ( f n [ p i p ] ( o r i g i n a l − s e r i e p i p ) ) p i p s ) ) )

( defn pip
[ original−serie k]
( l e t [ o r i g i n a l − l e n g t h ( count o r i g i n a l − s e r i e ) ]
( i f ( or (< k 3 ) (< o r i g i n a l − l e n g t h 3 ) (>= k o r i g i n a l − l e n g t h ) )
original−serie
( l e t [ c u r r e n t − p i p s [ 0 (− o r i g i n a l − l e n g t h 1 ) ] ]
( loop [ current−pips current−pips ]
( i f (< ( count c u r r e n t − p i p s ) k )
( r e c u r ( new−pip−seq o r i g i n a l − s e r i e c u r r e n t − p i p s ) )
( format−output o r i g i n a l − s e r i e c u r r e n t − p i p s ) ) ) ) ) ) )

36

Apˆndice B
e
Segunda Vers˜o
a
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25

26
27
28
29

;
;
;
;

Implementation of P e r c e p t u a l l y Important Points algorithm
Authors : Pedro H e n r i q u e s dos S a n t o s T e i x e i r a & Ronald Andreu K a i s e r
Second v e r s i o n
L a s t Updated : Sat 22 Nov 2010 0 5 : 0 4 : 0 5 PM BRST

( ns p i p
( : r e q u i r e [ c l o j u r e . c o n t r i b . math : a s math ] ) )

( d e f n max−key−index
”Returns [ key , i n d e x ] where ( f ( k item ) ) i s t h e g r e a t e s t . Most
a p p l i c a b l e to v e c t o r s . ”
[ f k & coll ]
( apply max−key f (map #(vec [ ( k %1) %2]) c o l l ( r a n g e ( count c o l l ) ) ) ) )

( d e f n max−key−value
”Returns [ key , v a l u e ] where ( f ( k item ) ) i s t h e g r e a t e s t . Most a p p l i c a b l e
to v e c t o r s . ”
[ f k & coll ]
( apply max−key f (map #(vec [ ( k %) %]) c o l l ) ) )

( d e f n max−distance
”Returns [ d i s t a n c e , i n d e x o f p o i n t ] where d i s t a n c e i s g r e a t e s t . The
e x t r e m e s a r e e x c l u d e d from c a n d i d a t e s s o t h e i n d e x r e t u r n e d i s
o f f s e t e d by 1 . p r e : t o > from + 1 . ”
[ s e r i e s from t o ]
( apply max−key−index f i r s t
( fn [ [ x y ] ]
( l e t [ [ x i y i ] ( s e r i e s from ) [ x f y f ] ( s e r i e s t o ) ]

37

30

31
32
33
34
35

36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67

( math/abs (− (+ ( d o u b l e y i ) ( ∗ (− ( d o u b l e y f ) ( d o u b l e y i ) ) ( / (− (
d o u b l e x ) ( d o u b l e x i ) ) (− ( d o u b l e x f ) ( d o u b l e x i ) ) ) ) ) ( d o u b l e y )
))))
( subvec s e r i e s (+ 1 from ) t o ) ) )

( defn max−distance−over−intervals
”Find new c a n d i d a t e p i p f o r each i n t e r v a l , and r e t u r n s [ [ d i s t a n c e
i n d e x − p o i n t − i n − i n t e r v a l ] i n t e r v a l ] f o r t h e i n t e r v a l where d i s t a n c e o f
the pip i s the g r e a t e s t . ”
[ s e r i e s pips ]
( l e t [ c a n d i d a t e − i n t e r v a l s ( f i l t e r ( f n [ [ p1 p2 ] ] (> p2 (+ 1 p1 ) ) ) p i p s ) ]
( when−not ( empty ? c a n d i d a t e − i n t e r v a l s )
( apply max−key−value f f i r s t #(apply max−distance s e r i e s %)
candidate−intervals ) ) ) )

( defn pip ∗
”Expect s e r i e s a s v e c t o r o f p o i n t s . p i p s i s a s e t o f [ s t a r t end ]
i n t e r v a l s which a r e d e f i n e d by t h e i m p o r t a n t p o i n t s e x t r a c t e d s o f a r .
Given t h e c u r r e n t i n t e r v a l s , t h i s f u n c t i o n c h o o s e s a new i m p o r t a n t p o i n t
with max d i s t a n c e a c r o s s a l l segments .
The new p o i n t i s used t o s p l i t one o f t h e c u r r e n t segments . ”
[ s e r i e s pips ]
( if−let [ [ [
r e l a t i v e − i n d e x − p i p ] [ p1 p2 : a s i n t e r v a l − t o − s p l i t ] ] (
max−distance−over−intervals s e r i e s pips ) ]
( l e t [ index−new−pip (+ 1 p1 r e l a t i v e − i n d e x − p i p ) ]
( conj ( d i s j pips interval−to−split )
[ p1 index−new−pip ] [ index−new−pip p2 ] ) ) ) )

( d e f n pip−seq
”Lazy s t r a t e g y u s i n g a r e c u r s i v e d e f i n i t i o n . ”
[ s e r i e s pips ]
( i f − l e t [ new−pips ( p i p ∗ s e r i e s p i p s ) ]
( cons new−pips
( l a z y − s e q ( pip−seq s e r i e s new−pips ) ) ) ) )

( defn find−pips
”Returns l a z y s e q u e n c e o f segments d e f i n e d by t h e i n d i c e s o f PIPs . The
extreme p o i n t s a r e g i v e n a s t h e f i r s t s e t o f PIPs . ”
([ series ]
( l e t [ e x t r e m e s [ 0 (− ( count s e r i e s ) 1 ) ] ]
( c o n j ( pip−seq s e r i e s #{e x t r e m e s } ) #{e x t r e m e s } ) ) )
([k series ]

38

68
69
70
71
72
73
74
75
76

( d i s t i n c t ( f l a t t e n ( vec ( nth ( f i n d − p i p s s e r i e s ) (− k 1 ) ) ) ) ) ) )

( defn pip
”Returns k p o i n t s more i m p o r t a n t s from s e r i e s . ”
[ series k]
( b i n d i n g [ max−distance ( memoize max−distance ) ]
( i f (<= ( count s e r i e s ) k ) s e r i e s
( sort−by f i r s t (map #( s e r i e s %) ( f i n d − p i p s k s e r i e s ) ) ) ) ) )

39

Apˆndice C
e
Terceira Vers˜o
a
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32

;
;
;
;

Implementation of P e r c e p t u a l l y Important Points Algorithm
Author : Ronald Andreu K a i s e r
Third Version − Optimized
L a s t Updated : Mon 29 Nov 2010 0 1 : 0 1 : 4 5 AM BRST

( ns p i p
( : use c l o j u r e . t e s t )
(: require
[ c l o j u r e . c o n t r i b . math : a s math ]
[ c l o j u r e . c o n t r i b . g e n e r i c . math−functions : a s math−functions ] ) )

( defn v e r t i c a l − d i s t a n c e
”Returns t h e v e r t i c a l d i s t a n c e between t h r e e p o i n t s .
P1 [ x1 y1 ] and P2 [ x2 y2 ] r e p r e s e n t t h e extreme l e f t and r i g h t PIPs
respectively .
P3 [ x3 y3 ] i s t h e c a n d i d a t e . ”
[ [ x1 y1 ] [ x3 y3 ] [ x2 y2 ] ]
( math/abs
(− (+ ( d o u b l e y1 )
( ∗ (− ( d o u b l e y2 ) ( d o u b l e y1 ) )
( / (− ( d o u b l e x3 ) ( d o u b l e x1 ) )
(− ( d o u b l e x2 ) ( d o u b l e x1 ) ) ) ) )
( d o u b l e y3 ) ) ) )

( d e f n max−in−interval
”Returns a v e c t o r with t h e b e s t d i s t a n c e thorough t h e i n t e r v a l with t h e
corresponding index in the o r i g i n a l − s e r i e .
Assumes t h a t t h e r e i s a t l e a s t one p o i n t between P1 and P2 . ”
[ o r i g i n a l − s e r i e [ p1−i n d e x p2−index : a s i n t e r v a l ] ]
( l e t [ p1 ( o r i g i n a l − s e r i e p1−i n d e x )

40

33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75

p2 ( o r i g i n a l − s e r i e p2−index ) ]
( reduce
( fn [ [ last−best−distance last−best−index : as last−best ]
candidate−index ]
( l e t [ c u r r e n t − d i s t a n c e ( v e r t i c a l − d i s t a n c e p1 ( o r i g i n a l − s e r i e
c a n d i d a t e − i n d e x ) p2 ) ]
( i f (> ( d o u b l e c u r r e n t − d i s t a n c e ) ( d o u b l e l a s t − b e s t − d i s t a n c e ) )
[ current−distance candidate−index ]
last−best ) ) )
[−1 −1]
( l a z y − s e q ( r a n g e ( i n c p1−i n d e x ) p2−index ) ) ) ) )

( d e f n find−max−from−intervals
”Returns t h e i n d e x o f t h e p o i n t i n o r i g i n a l − s e r i e t h a t i s most
d i s t a n t and t h e s u b j a c e n t i n t e r v a l . ”
[ original−serie intervals ]
( rest
( reduce
( fn [ [ last−best−distance last−best−index l a s t − i n t e r v a l : as last−best ]
current−interval ]
( l e t [ current−best
( i f (> (− ( i n t ( c u r r e n t − i n t e r v a l 1 ) ) ( i n t ( c u r r e n t − i n t e r v a l
0) ) ) 1)
( max−in−interval o r i g i n a l − s e r i e c u r r e n t − i n t e r v a l )
last−best ) ]
( i f (> ( d o u b l e ( c u r r e n t − b e s t 0 ) ) ( d o u b l e l a s t − b e s t − d i s t a n c e ) )
[ ( current−best 0) ( current−best 1) current−interval ]
last−best ) ) )
[−1 −1 [−1 − 1 ] ]
intervals )))

( d e f n format−output
”Returns a v e c t o r , which i s a t r a n s f o r m a t i o n o f t h e
c u r r e n t − i n t e r v a l s to p o int s in the o r i g i n a l − s e r i e
r e p r e s e n t i n g t h e f i n a l PIPs . ”
[ original−serie current−intervals ]
( l e t [ s o r t e d − i n t e r v a l s ( sort−by f i r s t ( vec c u r r e n t − i n t e r v a l s ) ) ]
( reduce
( fn [ l a s t − i n t e r v a l current−interval ]
( conj l a s t − i n t e r v a l ( o r i g i n a l − s e r i e ( current−interval 1) ) ) )
[( original−serie ( f f i r s t sorted−intervals ) ) ]
sorted−intervals ) ) )

( defn pip

41

76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121

”Returns a v e c t o r with t h e b e s t k PIPs from o r i g i n a l − s e r i e .
I f k i s g r e a t e r or equal the length of o r i g i n a l − s e r i e ,
r e t u r n s t h e same o r i g i n a l − s e r i e . ”
[ original−serie k]
( b i n d i n g [ max−in−interval ( memoize max−in−interval ) ]
( l e t [ o r i g i n a l − l e n g t h ( i n t ( count o r i g i n a l − s e r i e ) )
k ( int k) ]
( i f ( or (< k ( i n t 3 ) )
(< o r i g i n a l − l e n g t h ( i n t 3 ) )
(>= k o r i g i n a l − l e n g t h ) )
original−serie
( l e t [ c u r r e n t − i n t e r v a l s #{[0 (− o r i g i n a l − l e n g t h 1 ) ] } ]
( format−output
original−serie
( nth
( iterate
( fn [ current−intervals ]
( l e t [ new−pip−interval
( find−max−from−intervals o r i g i n a l − s e r i e ( l a z y− s e q
current−intervals ) )
p o i n t − t o − s p l i t ( f i r s t new−pip−interval )
i n t e r v a l − t o − s p l i t ( s e c o n d new−pip−interval ) ]
( conj ( d i s j current−intervals interval−to−split )
[ ( f i r s t interval−to−split ) point−to−split ]
[ point−to−split ( second i n t e r v a l − t o − s p l i t ) ] ) ) )
current−intervals )
( i n t (− k 2 ) ) ) ) ) ) ) ) )
;==================================
; find−max−from−intervals t e s t s
;==================================
( d e f t e s t find−max−from−intervals−test
( l e t [ i n p u t [ [ [ 1 2 ] [ 3 4 ] [ 5 3 0 ] [ 6 5 ] [ 9 7 ] ] #{[0 3 ] [ 3 4 ] } ]
expected [2 [0 3 ] ]
r e s u l t ( apply find−max−from−intervals i n p u t ) ]
( i s (= e x p e c t e d r e s u l t ) ) ) )
;==================================
; max−in−interval t e s t s
;==================================
( d e f t e s t max−in−interval−simple−case
( l e t [ input [ [ [ 1 2] [3 4] [5 30] [9 7 ] ] [0 3 ] ]
expected [ 2 5 . 5 2]
r e s u l t ( apply max−in−interval i n p u t ) ]
( i s ( math−functions / approx= ( f i r s t e x p e c t e d ) ( f i r s t r e s u l t ) 0 . 0 0 0 0 1 ) ) ) )

42

122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168

( d e f t e s t max−in−interval−simple−case−2
( l e t [ input [ [ [ 1 2] [3 1] [5 30] [9 2 ] ] [0 3 ] ]
expected [28 2]
r e s u l t ( apply max−in−interval i n p u t ) ]
( i s ( math−functions / approx= ( f i r s t e x p e c t e d ) ( f i r s t r e s u l t ) 0 . 0 0 0 0 1 ) ) ) )
;==================================
; pip t e s t s
;==================================
( d e f t e s t pip−empty−input
( l e t [ input [ ]
expected [ ]
k 2
r e s u l t ( pip input k ) ]
( i s (= e x p e c t e d r e s u l t ) ) ) )
( d e f t e s t pip−one−observation−input
( l e t [ input [ [ 1 2 ] ]
expected [ [ 1 2 ] ]
k 3
r e s u l t ( pip input k ) ]
( i s (= e x p e c t e d r e s u l t ) ) ) )
( d e f t e s t pip−two−observations−input
( l e t [ input [ [ 1 2] [2 3 ] ]
expected [ [ 1 2] [2 3 ] ]
k 3
r e s u l t ( pip input k ) ]
( i s (= e x p e c t e d r e s u l t ) ) ) )
( d e f t e s t p ip− s im p le− te s t− c a s e
( l e t [ input [ [ 1 2] [2 3] [3 50] [4 1 0 ] ]
expected [ [ 1 2] [3 50] [4 1 0 ] ]
k 3
r e s u l t ( pip input k ) ]
( i s (= e x p e c t e d r e s u l t ) ) ) )
( d e f t e s t pip−required−more−points−than−series−length
( l e t [ input [ [ 1 2] [2 3] [3 50] [4 1 0 ] ]
expected input
k 10
r e s u l t ( pip input k ) ]
( i s (= e x p e c t e d r e s u l t ) ) ) )
( deftest pip−testing−if−pip−is−evaluating−intervals−correctly
( l e t [ input [ [ 0 1] [1 2] [2 4] [3 10] [4 20] [5 1] [6 3]

43

169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215

[7 1] [8 10] [9 1] [10 10] [11 5] [12 30] [13 5]
[14 1] [15 9] [16 13] [17 1] [18 0] [19 20] [20 1]
[21 2] [22 4] [23 10] [24 5] [25 2] [26 50] [27 0]
[28 7] [29 8] [30 5] [31 4] [32 3] [33 2] [34 20]
[35 1] [36 3] [37 1] [38 10] [39 1] [40 10] [41 5]
[42 30] [43 5] [44 1] [45 9] [46 13] [47 1] [48 0]
[49 20] [50 1] [51 2] [52 4] [53 10] [54 20] [55 1]
[56 3] [57 1] [58 10] [59 1] [60 10] [61 5] [62 30]
[63 5] [64 1] [65 9] [66 13] [67 1] [68 0] [69 20]
[70 1] [71 2] [72 4] [73 10] [74 5] [75 2] [76 50]
[77 0] [78 7] [79 8] [80 5] [81 4] [82 3] [83 2]
[84 20] [85 1] [86 3] [87 1][88 10] [89 1] [90 10]
[91 5] [92 30] [93 5] [94 1] [95 9] [96 13] [97 1]
[98 0] [99 20] ]
expected [ [ 0 1] [12 30] [25 2] [26 50] [27 0]
[42 30] [75 2] [76 50] [77 0] [99 2 0 ]]
k 10
r e s u l t ( pip input k ) ]
( i s (= e x p e c t e d r e s u l t ) ) ) )
;==================================
; vertical−distance tests
;==================================
( deftest vertical−distance−colinearity
( l e t [ p1 [ 1 , 2 ]
p3 [ 2 , 3 ]
p2 [ 3 , 4 ]
expected 0
r e s u l t ( v e r t i c a l − d i s t a n c e p1 p3 p2 ) ]
( i s ( math−functions / approx= e x p e c t e d r e s u l t 0 . 0 0 0 0 1 ) ) ) )
( deftest vertical−distance−positive
( l e t [ p1 [ 1 , 2 ]
p3 [ 2 , 5 ]
p2 [ 3 , 2 ]
expected 3
r e s u l t ( v e r t i c a l − d i s t a n c e p1 p3 p2 ) ]
( i s ( math−functions / approx= e x p e c t e d r e s u l t 0 . 0 0 0 0 1 ) ) ) )
( deftest vertical−distance−negative
( l e t [ p1 [ 1 , 2 ]
p3 [ 2 , −1]
p2 [ 3 , 2 ]
expected 3
r e s u l t ( v e r t i c a l − d i s t a n c e p1 p3 p2 ) ]
( i s ( math−functions / approx= e x p e c t e d r e s u l t 0 . 0 0 0 0 1 ) ) ) )

44

216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233

( deftest vertical−distance−float−positive
( l e t [ p1 [ 1 , 2 ]
p3 [ 2 , 4 . 8 ]
p2 [ 3 , 5 ]
expected 1.3
r e s u l t ( v e r t i c a l − d i s t a n c e p1 p3 p2 ) ]
( i s ( math−functions / approx= e x p e c t e d r e s u l t 0 . 0 0 0 0 1 ) ) ) )
( deftest vertical−distance−float−negative
( l e t [ p1 [ 1 , 2 ]
p3 [ 2 , − 1 0 . 0 ]
p2 [ 3 , 5 ]
expected 13.5
r e s u l t ( v e r t i c a l − d i s t a n c e p1 p3 p2 ) ]
( i s ( math−functions / approx= e x p e c t e d r e s u l t 0 . 0 0 0 0 1 ) ) ) )

( run−tests )

45

Apˆndice D
e
Aproxima¸oes
c˜

Figura D.1: S´rie original – linha pontilhada em vermelho – com 8582 pontos represene
tando 1 mˆs de observa¸˜es, reduzida com PIP para 300 pontos. Descarte de 99.976% dos
e
co
pontos originais.

46

Referˆncias Bibliogr´ﬁcas
e
a
[1] reference
[2] reference
[3] reference
[4] reference
[5] reference
[6] reference
[7] reference
[8] reference
[9] reference
[10] reference
[11] reference
[12] reference
[13] reference
[14] reference
[15] reference

47

